1、策略模式  
	定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
	
	策略模式将定义与行为分开，如一个鸭子类，它可以继承出许多不同种类的鸭子，再定义一个行为类，如叫和飞。鸭子类
可以组合行为类，这样可以通过定义方法设置行为，如会飞与不会飞。这样可以控制鸭子的行为。
	通过组合的方式来扩展鸭子类的功能。
	
2、观察者模式
	定义对象之前的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
	
	观察者模式，由一个主题对象去管理所有观察对象，如向一个服务器类注册每一个DLG，当服务器类检测到服务器断开连
接，他会向每个DLG发送这个消息，让每个界面自己去处理这个消息。
	最适合观察者模式的描述是报纸，出版者和订阅者的关系。
	
3、装饰者模式
	动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
	
	针对抽象组件，将组件挨个附加，如最终求和。通过这种定义组件的方式可以最大的扩展。
	
4、工厂模式
	定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类；
	
	简单工厂模式的最大优点在用户工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户
端来说，去除了具体产品的依赖。
	
	简单工厂模式，子类继承基类，通过重写一个create方法传入需要创建的子类类型来创建不同的子类。
	
	(抽象工厂使用组合)（工厂方法继承把创建方法委托给子类）工厂模式，create方法放在抽象基类中有子类继承，通过调
用创建方法来创建子类而不需要传入类型参数。
	
5、单例模式
	确保一个类只有一个实例，并提供一个全局的访问点。
	
	两种方法，一、通过静态变量实例化一个类，然后通过函数去访问这个静态变量
	          二、通过第一次调用new一个对象，当再次访问时让它始终访问这个对象。但存在一个问题在多线程中，如果
			  这个创建函数同时进入，可能会导致创建多个对象，最好使用LOCK来同步线程，但会降低速度。
			  三、双重加锁机制，这样只有当第一次初始化的时候才会进入锁，其他时候会很快释放。
			  
6、命令模式
	将"请求"封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
	
	命令模式将每个设备作为接受者，把每个命令封装成为一个类。通过将设备绑定到命令上，然后调用管理类绑定命令组去
操作设备。可以将动作打包成一组命令来执行一个命令集合。

7、适配器模式与外观模式
	适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。

	适配器模式将一个类通过继承一个想要的接口类，将这个类封装成接口类。

	
	外观模式提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
	
	外观模式通过把系统中的一连串动作封装成为一个简单的方法，这样可以降低使用的难度。
	
8、模板方法模式
	模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结果
的情况下，重新定义算法中的某些步骤。

	将重复的步骤放到基类中基础，减少代码冗余。
	可以定义一个钩子来控制是否执行某些算法。通过if(是否做...)来判断是否执行这个操作。
	
9、迭代器和组合模式
	迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
	
	隐藏底层数据的实现结构，通过创建一个迭代器类去访问底层数据，这样一来上层可以不去关心他的数据类型。
	
	组合模式允许你将对象组合成树形结构来表现“整体、部分”层次结构。组合能让客户以一致的方式处理个别对象组合。
	
10、状态模式
	
	